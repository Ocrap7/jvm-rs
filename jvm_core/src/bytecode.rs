use bitflags::bitflags;

use jvm_macros::StreamReader;

use crate::{byte_stream::{ByteStream, ReaderContext, StreamRead}, bytecode::attribute_info::StackMapTable};

macro_rules! impl_read {
    ($ty:ty) => {
        impl<'a> $crate::byte_stream::VaryingRead<'a> for $ty {
            fn len(_: &'a [u8]) -> usize {
                std::mem::size_of::<$ty>()
            }

            fn read(data: &'a [u8]) -> $ty {
                $crate::byte_stream::cast_type(data)
            }
        }
    };
}

macro_rules! impl_tag {
    ($ty:ty, $val:expr) => {
        impl $ty {
            pub const TAG: u8 = $val;
        }
    };
    (@str $ty:ty, $val:expr) => {
        impl $ty {
            pub const TAG: &str = $val;
        }
    };
}

#[derive(Debug)]
pub struct ClassFile {
    magic: u32,
    minor_version: u16,
    major_version: u16,

    constant_pools: Vec<ConstantPool>,
    access_flags: AccessFlags,
    this_class: u16,
    super_class: u16,

    interfaces: Vec<u16>,
    fields: Vec<FieldInfo>,
    methods: Vec<MethodInfo>,
    attributes: Vec<AttributeInfo>,
}

impl ClassFile {
    pub fn read<'a>(stream: &'a mut ByteStream<'a>) -> Self {
        let mut ctx = ReaderContext {
            constant_pool: Vec::new(),
        };

        let magic = stream.read(&ctx);
        let minor_version = stream.read(&ctx);
        let major_version = stream.read(&ctx);

        println!(
            "{:X} {}.{} {}",
            magic, major_version, minor_version, stream.index
        );

        let constant_pool_count = stream.read::<u16>(&ctx) - 1;
        println!("{}", constant_pool_count);

        let mut constant_pools = vec![ConstantPool::Empty]; // Constant Pool indicies are 1 based indexed (i think), so add empty as an offset
        constant_pools.extend(stream.read_many(constant_pool_count as _, &ctx));

        ctx.constant_pool = constant_pools;

        let access_flags =
            AccessFlags::from_bits(stream.read(&ctx)).expect("Unable to read access flags!");
        let this_class = stream.read(&ctx);
        let super_class = stream.read(&ctx);

        let interface_count = stream.read::<u16>(&ctx);
        let interfaces = stream.read_many(interface_count as usize, &ctx);

        let field_count = stream.read::<u16>(&ctx);
        let fields = stream.read_many(field_count as usize, &ctx);

        let method_count = stream.read::<u16>(&ctx);
        let methods = stream.read_many(method_count as usize, &ctx);

        let attribute_count = stream.read::<u16>(&ctx);
        let attributes = stream.read_many(attribute_count as usize, &ctx);

        Self {
            magic,
            minor_version,
            major_version,

            constant_pools: ctx.constant_pool,
            access_flags,
            this_class,
            super_class,

            interfaces,
            fields,
            methods,
            attributes,
        }
    }

    pub fn methods(&self) -> &[MethodInfo] {
        &self.methods
    }

    pub fn fields(&self) -> &[FieldInfo] {
        &self.fields
    }

    pub fn get_str(&self, index: usize) -> &str {
        match &self.constant_pools[index] {
            ConstantPool::Utf8(str) => str.as_str(),
            _ => panic!("Expected string constant"),
        }
    }

    pub fn class_name(&self) -> &str {
        match &self.constant_pools[self.this_class as usize] {
            ConstantPool::Class(constant_pool::Class { name_index, .. }) => {
                return self.get_str(*name_index as usize)
            }
            _ => panic!("Expected class name!"),
        }
    }

    pub fn pool(&self, index: usize) -> &ConstantPool {
        &self.constant_pools[index]
    }
}

bitflags! {
    /// The value of the access_flags item is a mask of flags used
    /// to denote access permissions to and properties of this class or interface.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    struct AccessFlags: u16 {
        /// Declared public; may be accessed from outside its package.
        const PUBLIC = 0x0001;
        /// Declared private; usable only within the defining class.
        const PRIVATE = 0x0002;
        /// Declared protected; may be accessed within subclasses.
        const PROTECTED = 0x0004;
        /// Declared static.
        const STATIC = 0x0008;
        /// Declared final; no subclasses allowed.
        const FINAL = 0x0010;
        /// Treat superclass methods specially when invoked by the invokespecial instruction.
        const SUPER = 0x0020;
        /// Declared synchronized; invocation is wrapped by a monitor use.
        const SYNCHRONIZED = 0x0020;
        /// Declared volatile; cannot be cached.
        const VOLATILE = 0x0040;
        /// A bridge method, generated by the compiler.
        const BRIDGE = 0x0040;
        /// Declared transient; not written or read by a persistent object manager.
        const TRANSIENT = 0x0080;
        /// Declared with variable number of arguments.
        const VARARGS = 0x0080;
        /// Declared native; implemented in a language other than Java.
        const NATIVE = 0x0100;
        /// Is an interface, not a class.
        const INTERFACE = 0x0200;
        /// Declared abstract; must not be instantiated.
        const ABSTRACT = 0x0400;
        /// Declared strictfp; floating-point mode is FP-strict.
        const STRICT = 0x0800;
        /// Declared synthetic; not present in the source code.
        const SYNTHETIC = 0x1000;
        /// Declared as an annotation type.
        const ANNOTATION = 0x2000;
        /// Declared as an enum type.
        const ENUM = 0x4000;
    }
}

impl StreamRead for AccessFlags {
    fn read<'a>(stream: &mut ByteStream<'a>, ctx: &ReaderContext) -> Self {
        Self::from_bits_truncate(stream.read(ctx))
    }
}

#[repr(u8)]
#[derive(Clone, Debug)]
pub enum ConstantPool {
    Empty = 0,
    Class(constant_pool::Class) = 7,
    FieldRef(constant_pool::Ref) = 9,
    MethodRef(constant_pool::Ref) = 10,
    InterfaceMethodRef(constant_pool::Ref) = 11,
    String(constant_pool::String) = 8,
    Integer(constant_pool::Numeric) = 3,
    Float(constant_pool::Numeric) = 4,
    Long(constant_pool::LongNumeric) = 5,
    Double(constant_pool::LongNumeric) = 6,
    NameAndType(constant_pool::NameAndType) = 12,
    Utf8(constant_pool::Utf8) = 1,
    MethodHandle(constant_pool::MethodHandle) = 15,
    MethodType(constant_pool::MethodType) = 16,
    InvokeDynamic(constant_pool::InvokeDynamic) = 18,
}

impl StreamRead for ConstantPool {
    fn read<'a>(stream: &mut ByteStream<'a>, ctx: &ReaderContext) -> Self {
        let tag = stream.read::<u8>(ctx);

        match tag {
            constant_pool::Class::TAG => Self::Class(constant_pool::Class::read(stream, ctx)),
            constant_pool::FieldRef::TAG => Self::FieldRef(constant_pool::Ref::read(stream, ctx)),
            constant_pool::MethodRef::TAG => Self::MethodRef(constant_pool::Ref::read(stream, ctx)),
            constant_pool::InterfaceMethodRef::TAG => {
                Self::InterfaceMethodRef(constant_pool::Ref::read(stream, ctx))
            }
            constant_pool::String::TAG => Self::String(constant_pool::String::read(stream, ctx)),
            constant_pool::Integer::TAG => Self::Integer(constant_pool::Numeric::read(stream, ctx)),
            constant_pool::Float::TAG => Self::Float(constant_pool::Numeric::read(stream, ctx)),
            constant_pool::Long::TAG => Self::Long(constant_pool::LongNumeric::read(stream, ctx)),
            constant_pool::Double::TAG => {
                Self::Double(constant_pool::LongNumeric::read(stream, ctx))
            }
            constant_pool::NameAndType::TAG => {
                Self::NameAndType(constant_pool::NameAndType::read(stream, ctx))
            }
            constant_pool::Utf8::TAG => Self::Utf8(constant_pool::Utf8::read(stream, ctx)),
            constant_pool::MethodHandle::TAG => {
                Self::MethodHandle(constant_pool::MethodHandle::read(stream, ctx))
            }
            constant_pool::MethodType::TAG => {
                Self::MethodType(constant_pool::MethodType::read(stream, ctx))
            }
            constant_pool::InvokeDynamic::TAG => {
                Self::InvokeDynamic(constant_pool::InvokeDynamic::read(stream, ctx))
            }
            _ => unimplemented!(),
        }
    }
}

pub mod constant_pool {
    use jvm_macros::StreamReader;

    use crate::byte_stream::StreamRead;

    #[derive(Clone, Copy, Debug, StreamReader)]
    pub struct Class {
        pub name_index: u16,
    }

    #[derive(Clone, Copy, Debug, StreamReader)]
    pub struct Ref {
        pub class_index: u16,
        pub name_and_type_index: u16,
    }

    #[derive(Clone, Copy, Debug, StreamReader)]
    pub struct String {
        pub string_index: u16,
    }

    #[derive(Clone, Copy, Debug, StreamReader)]
    pub struct Numeric {
        pub bytes: u32,
    }

    #[derive(Clone, Copy, Debug, StreamReader)]
    pub struct LongNumeric {
        pub bytes: u64,
    }

    #[derive(Clone, Copy, Debug, StreamReader)]
    pub struct NameAndType {
        pub name_index: u16,
        pub descriptor_index: u16,
    }

    #[derive(Clone, Debug)]
    pub struct Utf8 {
        string: std::string::String,
    }

    impl Utf8 {
        pub fn as_str(&self) -> &str {
            &self.string
        }
    }

    #[derive(Clone, Copy, Debug, StreamReader)]
    pub struct MethodHandle {
        pub reference_kind: u8,
        pub reference_index: u16,
    }

    #[derive(Clone, Copy, Debug, StreamReader)]
    pub struct MethodType {
        pub descriptor_index: u16,
    }

    #[derive(Clone, Copy, Debug, StreamReader)]
    pub struct InvokeDynamic {
        pub bootstrap_method_attr_index: u16,
        pub name_and_type_index: u16,
    }

    pub struct MethodRef;
    pub struct FieldRef;
    pub struct InterfaceMethodRef;
    pub struct Integer;
    pub struct Float;
    pub struct Long;
    pub struct Double;

    impl StreamRead for Utf8 {
        fn read<'a>(
            stream: &mut crate::byte_stream::ByteStream<'a>,
            ctx: &crate::byte_stream::ReaderContext,
        ) -> Self {
            let len = stream.read::<u16>(ctx) as usize;
            stream.index += len;

            let data = &stream.data[stream.index - len..stream.index];

            Self {
                string: std::string::String::from_utf8_lossy(data).to_string(),
            }
        }
    }

    impl_tag!(Class, 7);
    impl_tag!(FieldRef, 9);
    impl_tag!(MethodRef, 10);
    impl_tag!(InterfaceMethodRef, 11);
    impl_tag!(String, 8);
    impl_tag!(Integer, 3);
    impl_tag!(Float, 4);
    impl_tag!(Long, 5);
    impl_tag!(Double, 6);
    impl_tag!(NameAndType, 12);
    impl_tag!(Utf8, 1);
    impl_tag!(MethodHandle, 15);
    impl_tag!(MethodType, 16);
    impl_tag!(InvokeDynamic, 18);
}

#[derive(Debug, StreamReader, Clone)]
pub struct FieldInfo {
    access_flags: AccessFlags,
    pub name_index: u16,
    pub descriptor_index: u16,
    #[many(u16)]
    attributes: Vec<AttributeInfo>,
}

impl FieldInfo {
    pub fn name<'a>(&'a self, file: &'a ClassFile) -> &'a str {
        file.get_str(self.name_index as usize)
    }
}

#[derive(Debug, StreamReader, Clone)]
pub struct MethodInfo {
    access_flags: AccessFlags,
    pub name_index: u16,
    pub descriptor_index: u16,
    #[many(u16)]
    attributes: Vec<AttributeInfo>,
}

impl MethodInfo {
    pub fn name<'a>(&'a self, file: &'a ClassFile) -> &'a str {
        file.get_str(self.name_index as usize)
    }

    pub fn code(&self) -> Option<attribute_info::Code> {
        self.attributes
            .iter()
            .find_map(|attr| match &attr.attribute {
                Attribute::Code(code) => Some(code.clone()),
                _ => None,
            })
    }
}

#[derive(Debug, Clone)]
pub struct AttributeInfo {
    attribute_name_index: u16,
    attribute: Attribute,
}

impl StreamRead for AttributeInfo {
    fn read<'a>(stream: &mut ByteStream<'a>, ctx: &ReaderContext) -> Self {
        let attribute_name_index = stream.read(ctx);
        let len = stream.read::<u32>(ctx) as usize;

        let attr = &ctx.constant_pool[attribute_name_index as usize];

        let old_index = stream.index;

        let attribute = match attr {
            ConstantPool::Utf8(str) => match str.as_str() {
                attribute_info::Code::TAG => {
                    Attribute::Code(attribute_info::Code::read(stream, ctx))
                }
                attribute_info::LineNumberTable::TAG => {
                    Attribute::LineNumberTable(attribute_info::LineNumberTable::read(stream, ctx))
                }
                attribute_info::SourceFile::TAG => {
                    Attribute::SourceFile(attribute_info::SourceFile::read(stream, ctx))
                }
                attribute_info::StackMapTable::TAG => {
                    stream.index += len;
                    Attribute::StackMapTable(StackMapTable {})
                }
                _ => panic!("Unknown attribute '{}'!", str.as_str()),
            },
            _ => panic!("Expected string in attribute index!"),
        };

        let dlength = stream.index - old_index;
        assert_eq!(dlength, len);

        AttributeInfo {
            attribute_name_index,
            attribute,
        }
    }
}

#[derive(Debug, Clone)]
pub enum Attribute {
    Code(attribute_info::Code),
    LineNumberTable(attribute_info::LineNumberTable),
    SourceFile(attribute_info::SourceFile),
    StackMapTable(attribute_info::StackMapTable),
}

pub mod attribute_info {
    use jvm_macros::StreamReader;

    use crate::byte_stream::StreamRead;

    use super::{AttributeInfo, ExceptionEntry};

    #[derive(Debug, Clone, StreamReader)]
    pub struct Code {
        pub max_stack: u16,
        pub max_locals: u16,

        #[many(u32)]
        pub instructions: Vec<u8>,

        #[many(u16)]
        pub exception_table: Vec<ExceptionEntry>,

        #[many(u16)]
        pub attributes: Vec<AttributeInfo>,
    }

    #[derive(Debug, Clone, StreamReader)]
    pub struct LineNumberTable {
        #[many(u16)]
        entries: Vec<LineNumber>,
    }

    #[derive(Debug, Clone, StreamReader)]
    pub struct LineNumber {
        start_pc: u16,
        line_number: u16,
    }

    #[derive(Debug, Clone, StreamReader)]
    pub struct SourceFile {
        source_file_index: u16,
    }

    #[derive(Debug, Clone, StreamReader)]
    pub struct StackMapTable {
        // #[many(u16)]
        // entries: Vec<StackMapFrame>,
    }

    #[derive(Debug, Clone)]
    pub struct StackMapFrame {}

    impl_tag!(@str Code, "Code");
    impl_tag!(@str LineNumberTable, "LineNumberTable");
    impl_tag!(@str SourceFile, "SourceFile");
    impl_tag!(@str StackMapTable, "StackMapTable");
}

#[derive(Debug, Clone, StreamReader)]
pub struct Op(u8);

#[derive(Debug, Clone, StreamReader)]
pub struct ExceptionEntry {
    start_pc: u16,
    end_pc: u16,
    handler_pc: u16,
    catch_type: u16,
}
